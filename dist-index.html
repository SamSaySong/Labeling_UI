<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="description" content="Video Bounding Box Labeling Tool" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Video Bounding Box Labeling Tool</title>
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body>
    <div id="root"></div>
    <script>
      // Inline compiled code for now
      const e = React;
      let t = e.useState, a = e.useRef, r = e.useEffect, o = e.useCallback;

      function UploadIcon() {
        return e.createElement("svg", {
          className: "w-4 h-4 mr-2",
          fill: "currentColor",
          viewBox: "0 0 20 20"
        }, e.createElement("path", {
          d: "M3 17a1 1 0 011-1h12a1 1 0 011 1v2a1 1 0 01-1 1H4a1 1 0 01-1-1v-2zm3.172-5.829a1 1 0 11-1.414-1.414L9 10.172V3a1 1 0 112 0v7.172l4.243-4.243a1 1 0 111.414 1.414l-6 6a1 1 0 01-1.414 0l-6-6z"
        }));
      }

      function TrashIcon() {
        return e.createElement("svg", {
          className: "w-4 h-4",
          fill: "currentColor",
          viewBox: "0 0 20 20"
        }, e.createElement("path", {
          fillRule: "evenodd",
          d: "M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z",
          clipRule: "evenodd"
        }));
      }

      function CopyIcon() {
        return e.createElement("svg", {
          className: "w-4 h-4",
          fill: "currentColor",
          viewBox: "0 0 20 20"
        }, e.createElement("path", {
          d: "M8 16.5a2.5 2.5 0 11-5 0 2.5 2.5 0 015 0z"
        }), e.createElement("path", {
          d: "M15 12.5a2.5 2.5 0 11-5 0 2.5 2.5 0 015 0z"
        }));
      }

      function CheckIcon() {
        return e.createElement("svg", {
          className: "w-4 h-4",
          fill: "currentColor",
          viewBox: "0 0 20 20"
        }, e.createElement("path", {
          fillRule: "evenodd",
          d: "M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z",
          clipRule: "evenodd"
        }));
      }

      function PencilIcon() {
        return e.createElement("svg", {
          className: "w-4 h-4",
          fill: "currentColor",
          viewBox: "0 0 20 20"
        }, e.createElement("path", {
          d: "M13.586 3.586a2 2 0 112.828 2.828l-.793.793-2.828-2.828.793-.793zM11.379 5.793L3 14.172V17h2.828l8.38-8.379-2.83-2.828z"
        }));
      }

      function App() {
        const [videoSrc, setVideoSrc] = t(null);
        const [videoFileName, setVideoFileName] = t("");
        const [labels, setLabels] = t([]);
        const [isDrawing, setIsDrawing] = t(false);
        const [isLabelingMode, setIsLabelingMode] = t(false);
        const [startPoint, setStartPoint] = t(null);
        const [currentRect, setCurrentRect] = t(null);
        const [videoDimensions, setVideoDimensions] = t({ width: 0, height: 0 });
        const [currentTime, setCurrentTime] = t(0);
        const [isCopied, setIsCopied] = t(false);

        const videoRef = a(null);
        const canvasRef = a(null);

        const handleFileChange = (event) => {
          const file = event.target.files?.[0];
          if (file) {
            const url = URL.createObjectURL(file);
            setVideoSrc(url);
            setVideoFileName(file.name);
            setLabels([]);
            setIsLabelingMode(false);
            setCurrentTime(0);
            if (videoRef.current) {
              videoRef.current.currentTime = 0;
            }
          }
        };

        const handleLoadedMetadata = () => {
          if (videoRef.current) {
            setVideoDimensions({
              width: videoRef.current.videoWidth,
              height: videoRef.current.videoHeight,
            });
            setTimeout(() => resizeCanvas(), 100);
          }
        };

        const handleTimeUpdate = () => {
          if (videoRef.current) {
            setCurrentTime(videoRef.current.currentTime);
          }
        };

        const draw = o(() => {
          const canvas = canvasRef.current;
          const video = videoRef.current;
          if (!canvas || !video || video.videoWidth === 0) return;

          const ctx = canvas.getContext("2d");
          if (!ctx) return;

          ctx.clearRect(0, 0, canvas.width, canvas.height);

          if (!isLabelingMode) return;

          const scaleX = canvas.width / 1920;
          const scaleY = canvas.height / 1080;

          ctx.strokeStyle = "rgba(255, 0, 0, 0.8)";
          ctx.lineWidth = 2;
          labels.forEach((label) => {
            const { xmin, ymin, xmax, ymax } = label.box;
            ctx.strokeRect(xmin * scaleX, ymin * scaleY, (xmax - xmin) * scaleX, (ymax - ymin) * scaleY);
          });

          if (isDrawing && currentRect) {
            ctx.strokeStyle = "rgba(0, 255, 0, 0.8)";
            ctx.strokeRect(currentRect.x, currentRect.y, currentRect.width, currentRect.height);
          }
        }, [labels, isDrawing, currentRect, isLabelingMode]);

        const resizeCanvas = o(() => {
          const video = videoRef.current;
          const canvas = canvasRef.current;
          const container = video?.parentElement;
          if (video && canvas && container && video.videoWidth > 0 && video.videoHeight > 0) {
            const { clientWidth } = container;
            const aspectRatio = video.videoHeight / video.videoWidth;
            canvas.width = clientWidth;
            canvas.height = clientWidth * aspectRatio;
            setTimeout(() => draw(), 50);
          }
        }, [draw]);

        r(() => {
          const handleResize = () => resizeCanvas();
          window.addEventListener("resize", handleResize);
          return () => {
            window.removeEventListener("resize", handleResize);
          };
        }, [resizeCanvas]);

        r(() => {
          draw();
        }, [labels, isDrawing, currentRect, draw]);

        const getScaledPoint = (evt) => {
          const canvas = canvasRef.current;
          if (!canvas) return { x: 0, y: 0 };
          const rect = canvas.getBoundingClientRect();
          return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top,
          };
        };

        const handleMouseDown = (evt) => {
          if (!isLabelingMode || !videoRef.current || videoRef.current.paused === false) {
            return;
          }
          setIsDrawing(true);
          const point = getScaledPoint(evt);
          setStartPoint(point);
          setCurrentRect(null);
        };

        const handleMouseMove = (evt) => {
          if (!isDrawing || !startPoint) return;

          const currentPoint = getScaledPoint(evt);
          const rect = {
            x: Math.min(startPoint.x, currentPoint.x),
            y: Math.min(startPoint.y, currentPoint.y),
            width: Math.abs(startPoint.x - currentPoint.x),
            height: Math.abs(startPoint.y - currentPoint.y),
          };
          setCurrentRect(rect);
        };

        const handleMouseUp = () => {
          if (!isDrawing || !startPoint || !currentRect || !videoRef.current || !canvasRef.current) return;
          setIsDrawing(false);

          if (currentRect.width < 5 || currentRect.height < 5) {
            setStartPoint(null);
            setCurrentRect(null);
            return;
          }

          const { width: canvasWidth, height: canvasHeight } = canvasRef.current;
          const targetWidth = 1920;
          const targetHeight = 1080;

          const scaleX = targetWidth / canvasWidth;
          const scaleY = targetHeight / canvasHeight;

          const newLabel = {
            id: new Date().toISOString(),
            timestamp: videoRef.current.currentTime,
            box: {
              xmin: Math.round(currentRect.x * scaleX),
              ymin: Math.round(currentRect.y * scaleY),
              xmax: Math.round((currentRect.x + currentRect.width) * scaleX),
              ymax: Math.round((currentRect.y + currentRect.height) * scaleY),
            },
          };

          setLabels((prev) => [...prev, newLabel]);
          setStartPoint(null);
          setCurrentRect(null);
        };

        const handleDeleteLabel = (id) => {
          setLabels((prev) => prev.filter((label) => label.id !== id));
        };

        const handleVideoError = (evt) => {
          const video = evt.currentTarget;
          console.error("Video error:", {
            error: video.error,
            errorCode: video.error?.code,
            errorMessage: video.error?.message,
            src: video.src,
          });
        };

        const handleToggleLabelingMode = () => {
          setIsLabelingMode((prev) => {
            const newMode = !prev;
            if (newMode && videoRef.current && !videoRef.current.paused) {
              videoRef.current.pause();
            }
            return newMode;
          });
        };

        const formatTime = (time) => {
          if (isNaN(time) || time < 0) return "00:00";
          const roundedTime = Math.floor(time);
          const minutes = Math.floor(roundedTime / 60);
          const seconds = roundedTime % 60;
          return `${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")}`;
        };

        const generatedJson = JSON.stringify(
          labels.map((l) => ({
            eventStart: formatTime(l.timestamp),
            eventEnd: formatTime(l.timestamp),
            area: [l.box.xmin, l.box.ymin, l.box.xmax, l.box.ymax],
          })),
          null,
          2
        );

        const handleCopyJson = async () => {
          try {
            if (navigator.clipboard && navigator.clipboard.writeText) {
              await navigator.clipboard.writeText(generatedJson);
            } else {
              const textArea = document.createElement("textarea");
              textArea.value = generatedJson;
              document.body.appendChild(textArea);
              textArea.select();
              document.execCommand("copy");
              document.body.removeChild(textArea);
            }
            setIsCopied(true);
            setTimeout(() => setIsCopied(false), 2000);
          } catch (err) {
            console.error("Failed to copy:", err);
            alert("Failed to copy to clipboard");
          }
        };

        return e.createElement(
          "div",
          { className: "min-h-screen bg-gray-900 text-gray-200 p-3 sm:p-4 lg:p-6" },
          e.createElement(
            "div",
            { className: "w-full mx-auto" },
            e.createElement(
              "header",
              { className: "mb-6" },
              e.createElement("h1", { className: "text-3xl sm:text-4xl font-bold text-cyan-400" }, "Video Bounding Box Labeling Tool"),
              e.createElement("p", { className: "mt-2 text-gray-400" }, "Import a video, use the controls to activate labeling, and draw boxes. The tool will generate timestamped coordinates scaled to 1920x1080.")
            ),
            e.createElement(
              "main",
              { className: "grid grid-cols-1 lg:grid-cols-11 gap-3" },
              e.createElement(
                "div",
                { className: "lg:col-span-8 bg-gray-800 rounded-lg p-4 shadow-2xl flex flex-col" },
                !videoSrc
                  ? e.createElement(
                      "div",
                      { className: "w-full min-h-[600px] flex flex-col items-center justify-center border-2 border-dashed border-gray-600 rounded-lg flex-grow" },
                      e.createElement("h2", { className: "text-base font-semibold mb-4 text-gray-300" }, "Import Your Video"),
                      e.createElement(
                        "label",
                        { className: "bg-cyan-500 hover:bg-cyan-600 text-white font-bold py-2 px-4 rounded-lg cursor-pointer transition-colors duration-300 flex items-center text-sm" },
                        e.createElement(UploadIcon),
                        e.createElement("span", null, "Choose File"),
                        e.createElement("input", { type: "file", accept: "video/*", className: "hidden", onChange: handleFileChange })
                      )
                    )
                  : e.createElement(
                      e.Fragment,
                      null,
                      e.createElement(
                        "div",
                        { className: "flex justify-between items-center mb-3 flex-shrink-0 gap-2" },
                        e.createElement(
                          "button",
                          {
                            onClick: handleToggleLabelingMode,
                            className: `flex items-center gap-1 px-2 py-1 rounded text-xs font-semibold transition-colors ${
                              isLabelingMode
                                ? "bg-cyan-500 text-white hover:bg-cyan-600"
                                : "bg-gray-700 text-gray-200 hover:bg-gray-600"
                            }`,
                            "aria-pressed": isLabelingMode,
                          },
                          e.createElement(PencilIcon),
                          e.createElement("span", { className: "hidden sm:inline" }, isLabelingMode ? "Label" : "Label")
                        ),
                        e.createElement(
                          "label",
                          { className: "bg-gray-700 hover:bg-gray-600 text-white font-bold py-1 px-2 rounded-lg cursor-pointer transition-colors duration-300 flex items-center text-xs" },
                          e.createElement(UploadIcon),
                          e.createElement("span", { className: "ml-1 hidden sm:inline" }, "New"),
                          e.createElement("input", { type: "file", accept: "video/*", className: "hidden", onChange: handleFileChange })
                        )
                      ),
                      e.createElement(
                        "div",
                        { className: "relative w-full aspect-video bg-black rounded-md" },
                        e.createElement("video", {
                          ref: videoRef,
                          src: videoSrc,
                          controls: true,
                          className: "w-full h-full rounded-md",
                          onLoadedMetadata: handleLoadedMetadata,
                          onTimeUpdate: handleTimeUpdate,
                          onPlay: () => isLabelingMode && setIsLabelingMode(false),
                          onLoadStart: () => console.log("Video loading started"),
                          onError: handleVideoError,
                          crossOrigin: "anonymous",
                        }),
                        e.createElement("canvas", {
                          ref: canvasRef,
                          className: `absolute top-0 left-0 w-full h-full ${isLabelingMode ? "cursor-crosshair" : "pointer-events-none"}`,
                          onMouseDown: handleMouseDown,
                          onMouseMove: handleMouseMove,
                          onMouseUp: handleMouseUp,
                          onMouseLeave: handleMouseUp,
                        }),
                        e.createElement(
                          "div",
                          { className: "absolute bottom-16 sm:bottom-12 right-2 pointer-events-none" },
                          e.createElement(
                            "div",
                            { className: "bg-black bg-opacity-50 text-white px-2 py-1 rounded text-sm font-mono" },
                            formatTime(currentTime)
                          )
                        )
                      ),
                      e.createElement(
                        "div",
                        { className: "mt-3 text-center flex-shrink-0" },
                        e.createElement("p", { className: "text-sm text-gray-400 truncate", title: videoFileName }, e.createElement("strong", null, "Now playing:"), " ", videoFileName),
                        e.createElement("p", { className: "text-sm text-gray-500 mt-1" }, isLabelingMode ? "Seek to a frame and draw a box." : "Activate the label tool to start drawing.")
                      )
                    )
              ),
              e.createElement(
                "div",
                { className: "lg:col-span-3 bg-gray-800 rounded-lg p-4 shadow-2xl flex flex-col" },
                e.createElement("h2", { className: "text-lg font-semibold mb-3 border-b border-gray-700 pb-2 text-cyan-400" }, "Generated Labels"),
                e.createElement(
                  "div",
                  { className: "space-y-2 max-h-[50vh] overflow-y-auto pr-2" },
                  labels.length === 0
                    ? e.createElement("p", { className: "text-gray-500" }, "No labels created yet.")
                    : labels
                        .slice()
                        .reverse()
                        .map((label) => {
                          const box = label.box;
                          const w = box.xmax - box.xmin;
                          const h = box.ymax - box.ymin;

                          return e.createElement(
                            "div",
                            { key: label.id, className: "bg-gray-700 p-2 rounded-lg text-xs group" },
                            e.createElement(
                              "div",
                              { className: "flex justify-between items-start" },
                              e.createElement(
                                "div",
                                null,
                                e.createElement("p", { className: "font-semibold text-cyan-300" }, "Time: ", e.createElement("span", { className: "font-mono text-white" }, formatTime(label.timestamp))),
                                e.createElement("p", { className: "font-mono text-gray-300 mt-1" }, e.createElement("span", { className: "font-sans font-semibold text-gray-400" }, "xywh:"), " ", box.xmin, ", ", box.ymin, ", ", w, ", ", h),
                                e.createElement("p", { className: "font-mono text-gray-300" }, e.createElement("span", { className: "font-sans font-semibold text-gray-400" }, "minmax:"), " ", box.xmin, ", ", box.ymin, ", ", box.xmax, ", ", box.ymax)
                              ),
                              e.createElement(
                                "button",
                                {
                                  onClick: () => handleDeleteLabel(label.id),
                                  className: "text-gray-500 hover:text-red-500 transition-colors opacity-0 group-hover:opacity-100",
                                  "aria-label": "Delete label",
                                },
                                e.createElement(TrashIcon)
                              )
                            )
                          );
                        })
                ),
                e.createElement(
                  "div",
                  { className: "mt-6" },
                  e.createElement(
                    "div",
                    { className: "flex justify-between items-center mb-2" },
                    e.createElement("h3", { className: "text-xl font-semibold text-cyan-400" }, "JSON Output (1920x1080)"),
                    e.createElement(
                      "button",
                      {
                        onClick: handleCopyJson,
                        className: "flex items-center text-sm bg-cyan-600 hover:bg-cyan-700 text-white px-3 py-2 rounded-md transition-colors disabled:opacity-50 disabled:cursor-not-allowed",
                        disabled: labels.length === 0,
                        type: "button",
                      },
                      isCopied ? e.createElement(CheckIcon) : e.createElement(CopyIcon),
                      e.createElement("span", { className: "ml-2" }, isCopied ? "Copied!" : "Copy")
                    )
                  ),
                  e.createElement("pre", { className: "bg-gray-900 rounded-md p-4 text-xs text-green-300 overflow-auto max-h-48 font-mono" }, e.createElement("code", null, generatedJson))
                )
              )
            )
          )
        );
      }

      // Render app
      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(React.createElement(App));
    </script>
    <script crossorigin src="https://unpkg.com/react@19/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@19/umd/react-dom.production.min.js"></script>
  </body>
</html>
